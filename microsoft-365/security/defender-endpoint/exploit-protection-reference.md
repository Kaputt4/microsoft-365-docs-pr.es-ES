---
title: Referencia de protección contra vulnerabilidades de seguridad
keywords: mitigaciones, vulnerabilidades, vulnerabilidad, mitigación, vulnerabilidad, vulnerabilidades, vulnerabilidades, emet
description: Detalles sobre cómo funciona la característica de protección contra vulnerabilidades en Windows 10
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.openlocfilehash: 7300ed2a4dc2623a8f936006ce7de3a5204712f0
ms.sourcegitcommit: 4fb1226d5875bf5b9b29252596855a6562cea9ae
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 06/08/2021
ms.locfileid: "52844548"
---
# <a name="exploit-protection-reference"></a>Referencia de protección contra vulnerabilidades

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**Se aplica a:**
- [Microsoft Defender para punto de conexión](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

>¿Desea experimentar Microsoft Defender para endpoint? [Regístrate para obtener una versión de prueba gratuita.](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

La protección contra vulnerabilidades proporciona protecciones avanzadas para las aplicaciones que el Pro de TI puede aplicar después de que el desarrollador haya compilado y distribuido el software.

Este artículo le ayuda a comprender cómo funciona la protección contra vulnerabilidades, tanto en el nivel de directiva como en el nivel de mitigación individual, para ayudarle a crear y aplicar correctamente directivas de protección contra vulnerabilidades de seguridad.

## <a name="how-mitigations-are-applied"></a>Cómo se aplican las mitigaciones

Las mitigaciones de protección contra vulnerabilidades de seguridad se aplican por aplicación.

Las mitigaciones se configuran a través de una entrada del Registro para cada programa para el que configure las protecciones. Esta configuración se almacena en la entrada del Registro **MitigationOptions** para cada programa (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). Tienen efecto al reiniciar el programa y permanecen vigentes hasta que los cambie y reinicie de nuevo el programa.

> [!IMPORTANT]
> Opciones de ejecución de archivos de imagen solo permite especificar un nombre de archivo o una ruta de acceso, y no un número de versión, arquitectura ni ningún otro diferenciador. Tenga cuidado de dirigir las mitigaciones a las aplicaciones que tienen nombres o rutas de acceso únicos, apliquen solo en dispositivos donde haya probado esa versión y la arquitectura de la aplicación.

Si configura mitigaciones de protección contra vulnerabilidades mediante un archivo de configuración XML, ya sea mediante PowerShell, directiva de grupo o MDM, al procesar este archivo de configuración XML, se configurarán automáticamente las opciones de configuración individuales del Registro.

Cuando ya no se aplica la directiva que distribuye el archivo XML, la configuración implementada por este archivo de configuración XML no se quitará automáticamente. Para quitar la configuración de Protección contra vulnerabilidades de seguridad, exporte la configuración XML desde un dispositivo Windows 10 y implemente este nuevo archivo XML. Como alternativa, Microsoft proporciona un archivo XML como parte de las Seguridad de Windows baselines para restablecer la configuración de Protección contra vulnerabilidades de seguridad.

Para restablecer la configuración de protección contra vulnerabilidades con PowerShell, puede usar el siguiente comando:

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
A continuación se EP-reset.xml distribución con las Seguridad de Windows líneas base:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Referencia de mitigación

En las secciones siguientes se detallan las protecciones proporcionadas por cada mitigación de protección contra vulnerabilidades, las consideraciones de compatibilidad para la mitigación y las opciones de configuración disponibles.

## <a name="arbitrary-code-guard"></a>Protección de código arbitraria

### <a name="description"></a>Descripción

La protección de código arbitraria ayuda a proteger contra un atacante malintencionado que carga el código de su elección en la memoria a través de una vulnerabilidad de seguridad de memoria y poder ejecutar ese código.

La protección de código arbitraria protege a una aplicación de la ejecución de código generado dinámicamente (código que no se carga, por ejemplo, del propio archivo exe o dll). La protección de código arbitraria funciona evitando que la memoria se marque como ejecutable. Cuando una aplicación intenta [asignar memoria,](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)se comprueban las marcas de protección. (La memoria se puede asignar con marcas de protección de lectura, escritura o ejecución). Si la asignación intenta incluir la marca [*de*](/windows/win32/memory/memory-protection-constants) protección de ejecución, se produce un error en la asignación de memoria y se devuelve un código de error (STATUS_DYNAMIC_CODE_BLOCKED). Del mismo modo, si [](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) una aplicación intenta cambiar las marcas de protección [](/windows/win32/memory/memory-protection-constants) de memoria que ya se han asignado e incluye la marca de protección de ejecución, el cambio de permisos falla y devuelve un código de error (STATUS_DYNAMIC_CODE_BLOCKED).

Al impedir que *se establezca* la marca de ejecución, la característica de prevención de ejecución de datos de Windows 10 puede proteger contra el puntero de instrucción que se va a establecer en esa memoria y ejecutar ese código.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

La protección de código arbitraria impide asignar cualquier memoria como ejecutable, lo que presenta un problema de compatibilidad con métodos como compiladores Just-in-Time (JIT). La mayoría de los exploradores modernos, por ejemplo, compilarán JavaScript en código nativo para optimizar el rendimiento. Para admitir esta mitigación, tendrán que rearchitected para mover la compilación JIT fuera del proceso protegido. Otras aplicaciones cuyo diseño genera dinámicamente código a partir de scripts u otros lenguajes intermedios serán igualmente incompatibles con esta mitigación.

### <a name="configuration-options"></a>Opciones de configuración

**Permitir la exclusión de subprocesos:** puede configurar la mitigación para permitir que un subproceso individual opte por no participar en esta protección. El desarrollador debe haber escrito la aplicación con conocimiento de esta mitigación y haber llamado a la API [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) con el parámetro *ThreadInformation* establecido en **ThreadDynamicCodePolicy** para poder ejecutar código dinámico en este subproceso.

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-low-integrity-images"></a>Bloquear imágenes de baja integridad

### <a name="description"></a>Descripción

Bloquear imágenes de baja integridad impide que la aplicación cargue archivos que no son de confianza, normalmente porque se han descargado de Internet desde un explorador de espacio aislado.

Esta mitigación bloqueará las cargas de imágenes si la imagen tiene una entrada de control de acceso (ACE) que concede acceso a los procesos de IL baja y que no tiene una ace de etiqueta de confianza. Lo implementa el administrador de memoria, que impide que el archivo se asigne a la memoria. Si una aplicación intenta asignar una imagen de baja integridad, desencadenará un error STATUS_ACCESS_DENIED. Para obtener más información sobre cómo funcionan los niveles de integridad, vea [Mandatory Integrity Control](/windows/win32/secauthz/mandatory-integrity-control).

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Bloquear imágenes de baja integridad impedirá que la aplicación cargue los archivos que se descargaron de Internet. Si el flujo de trabajo de la aplicación requiere cargar imágenes que se descargan, querrá asegurarse de que se descargan de un proceso de mayor confianza o que se vuelvan a etiquetar explícitamente para aplicar esta mitigación.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-remote-images"></a>Bloquear imágenes remotas

### <a name="description"></a>Descripción

El bloqueo de imágenes remotas ayuda a impedir que la aplicación cargue archivos hospedados en un dispositivo remoto, como un recurso compartido UNC. El bloqueo de imágenes remotas ayuda a proteger contra la carga de archivos binarios en la memoria que se encuentran en un dispositivo externo controlado por el atacante.

Esta mitigación bloqueará las cargas de imágenes si se determina que la imagen está en un dispositivo remoto. Lo implementa el administrador de memoria, que impide que el archivo se asigne a la memoria. Si una aplicación intenta asignar un archivo remoto, desencadenará un STATUS_ACCESS_DENIED error.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Bloquear imágenes remotas impedirá que la aplicación cargue imágenes desde dispositivos remotos. Si la aplicación carga archivos o complementos desde dispositivos remotos, no será compatible con esta mitigación.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-untrusted-fonts"></a>Bloquear fuentes que no son de confianza

### <a name="description"></a>Descripción

Bloquear fuentes que no son de confianza mitiga el riesgo de un error en el análisis de fuentes que hace que el atacante pueda ejecutar código en el dispositivo. Solo las fuentes instaladas en el directorio windows\fonts se cargarán para su procesamiento por GDI.

Esta mitigación se implementa en GDI, que valida la ubicación del archivo. Si el archivo no está en el directorio de fuentes del sistema, la fuente no se cargará para el análisis y esa llamada producirá un error.

Esta mitigación se suma a la mitigación integrada proporcionada en Windows 10 1607 y versiones posteriores, que mueve el análisis de fuentes fuera del kernel y a un contenedor de aplicaciones en modo de usuario. Cualquier vulnerabilidad basada en el análisis de fuentes, como resultado, se produce en un contexto aislado y aislado, lo que reduce significativamente el riesgo. Para obtener más información sobre esta mitigación, consulte el blog [Hardening Windows 10 with zero-day exploit mitigations](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/).

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

El uso más común de fuentes fuera del directorio de fuentes del sistema es con [fuentes web.](/typography/fonts/font-faq#web) Los exploradores modernos, como Microsoft Edge, usan DirectWrite en lugar de GDI y no se verán afectados. Sin embargo, los exploradores heredados, como Internet Explorer 11 (y el modo IE en el nuevo Microsoft Edge) se pueden ver afectados, especialmente con aplicaciones como Office 365, que usan glifos de fuente para mostrar la interfaz de usuario.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="code-integrity-guard"></a>Protección de integridad de código

### <a name="description"></a>Descripción

La protección de integridad de código garantiza que Microsoft firme digitalmente todos los archivos binarios cargados en un proceso. La protección de integridad de código incluye firmas [WHQL](/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs), lo que permitirá que los controladores aprobados por WHQL se ejecuten dentro del proceso.

Esta mitigación se implementa en el administrador de memoria, lo que impide que el binario se asigne a la memoria. Si intenta cargar un binario que No está firmado por Microsoft, el administrador de memoria devolverá el error STATUS_INVALID_IMAGE_HASH. Al bloquear en el nivel del administrador de memoria, se evitan los archivos binarios cargados por el proceso y los archivos binarios que se insertan en el proceso.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación bloquea específicamente cualquier binario que no esté firmado por Microsoft. Por lo tanto, será incompatible con la mayoría del software de terceros, a menos que el Microsoft Store lo distribuye (y lo firme digitalmente) y se seleccione la opción para permitir la carga de imágenes firmadas por el Microsoft Store.

### <a name="configuration-options"></a>Opciones de configuración

También permitir la carga de imágenes firmadas por **Microsoft Store:** las aplicaciones distribuidas por el Microsoft Store se firmarán digitalmente por el Microsoft Store y agregar esta configuración permitirá que los archivos binarios que han pasado por el proceso de certificación del almacén se carguen por la aplicación.

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="control-flow-guard-cfg"></a>Protección de flujo de control (CFG)

### <a name="description"></a>Descripción

La protección de flujo de control (CFG) mitiga el riesgo de que los atacantes usen vulnerabilidades de daños en la memoria mediante la protección de llamadas a funciones indirectas. Por ejemplo, un atacante puede usar una vulnerabilidad de desbordamiento de búfer para sobrescribir la memoria que contiene un puntero de función y reemplazar ese puntero de función por un puntero al código ejecutable de su elección (que también se puede haber inyectado en el programa).

Esta mitigación se proporciona mediante la inyección de otra comprobación en tiempo de compilación. Antes de cada llamada de función indirecta, se agregan otras instrucciones que comprueban que el destino es un destino de llamada válido antes de que se llame. Si el destino no es un destino de llamada válido, la aplicación finaliza. Por lo tanto, solo las aplicaciones compiladas con compatibilidad con CFG pueden beneficiarse de esta mitigación.

La comprobación de un destino válido la proporciona Windows kernel. Cuando se cargan archivos ejecutables, los metadatos de los destinos de llamadas indirectos se extraen en tiempo de carga y se marcan como destinos de llamadas válidos. Además, cuando la memoria se asigna y se marca como ejecutable (por ejemplo, para el código generado), estas ubicaciones de memoria también se marcan como destinos de llamadas válidos, para admitir mecanismos como la compilación de JIT.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Dado que las aplicaciones deben compilarse para admitir CFG, declaran implícitamente su compatibilidad con él. Por lo tanto, la mayoría de las aplicaciones deben funcionar con esta mitigación habilitada. Dado que estas comprobaciones se compilan en el binario, la configuración que puede aplicar es simplemente para deshabilitar las comprobaciones dentro del kernel Windows. En otras palabras, la mitigación está en modo predeterminado, pero puede configurar el kernel de Windows para que siempre devuelva "sí" si más adelante determina que hay un problema de compatibilidad que el desarrollador de aplicaciones no detectó en sus pruebas, lo que debería ser poco frecuente.

### <a name="configuration-options"></a>Opciones de configuración

**Usar CFG** estricto: en modo estricto, todos los archivos binarios cargados en el proceso deben compilarse para Control Flow Guard (o no tienen código ejecutable en ellos, como dll de recursos) para poder cargarse.

> [!Note]
> **La protección de flujo de** control no tiene modo de auditoría. Los archivos binarios se compilan con esta mitigación habilitada.

## <a name="data-execution-prevention-dep"></a>Prevención de ejecución de datos (DEP)

### <a name="description"></a>Descripción

La prevención de ejecución de datos (DEP) impide que se ejecute la memoria que no se asignó explícitamente como ejecutable. DEP ayuda a proteger contra un atacante que inserta código malintencionado en el proceso, por ejemplo, a través de un desbordamiento de búfer y, a continuación, ejecuta ese código.

Si intenta establecer el puntero de instrucción en una dirección de memoria no marcada como ejecutable, el procesador producirá una excepción (infracción de protección general), lo que provocará que la aplicación se bloquea.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Todos los ejecutables x64, ARM y ARM-64 tienen DEP habilitado de forma predeterminada y no se puede deshabilitar. Dado que una aplicación nunca se habrá ejecutado sin DEP, se asume la compatibilidad.

Todos los archivos binarios x86 (32 bits) tienen DEP habilitado de forma predeterminada, pero DEP se puede deshabilitar por proceso. Es posible que algunas aplicaciones heredadas antiguas, normalmente aplicaciones desarrolladas antes de Windows XP SP2, no sean compatibles con DEP. Estas aplicaciones suelen generar código dinámicamente (por ejemplo, compilación de JIT) o vínculo a bibliotecas antiguas (como versiones anteriores de ATL) que generan código dinámicamente.

### <a name="configuration-options"></a>Opciones de configuración

**Habilitar la emulación de Thunk atl:** esta opción de configuración deshabilita la emulación de Atl Thunk. ATL, la ActiveX de plantillas, está diseñada para ser lo más pequeña y rápida posible. Para reducir el tamaño binario, usaría una técnica denominada *thunking*. La thunking suele estar pensado para interactuar entre aplicaciones de 32 bits y 16 bits, pero aquí no hay componentes de 16 bits para ATL. En su lugar, para optimizar el tamaño binario, ATL almacenará código de máquina en la memoria que no esté alineado con palabras (creando un binario más pequeño) y, a continuación, invocará ese código directamente. Los componentes ATL compilados con Visual Studio 7.1 o versiones anteriores (Visual Studio 2003) no asignan esta memoria como ejecutable: la emulación de thunk resuelve ese problema de compatibilidad. Las aplicaciones que tienen un modelo de extensión binaria (como Internet Explorer 11) a menudo tendrán que tener habilitada la emulación de Thunk atl.

## <a name="disable-extension-points"></a>Deshabilitar puntos de extensión

### <a name="description"></a>Descripción

Esta mitigación deshabilita varios puntos de extensión para una aplicación, que podrían usarse para establecer la persistencia o elevar los privilegios de contenido malintencionado.

Esto incluye:

- **DLL de AppInit:** cada vez que se inicia un proceso, el sistema cargará la DLL especificada en el contexto del proceso recién iniciado antes de llamar a su función de punto de entrada. [Los detalles de las DLL de AppInit se pueden encontrar aquí](/windows/win32/winmsg/about-window-classes#application-global-classes). Con esta mitigación aplicada, las DLL de AppInit no se cargan. A partir de Windows 7, las DLL de AppInit deben firmarse digitalmente, [como se describe aquí](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2). Además, a partir de Windows 8, las DLL de AppInit no se cargarán si SecureBoot está habilitado, [como se describe aquí](/windows/win32/dlls/secure-boot-and-appinit-dlls).
- **IME** heredado: un Editor de métodos de entrada (IME) permite al usuario escribir texto en un idioma con más caracteres de los que se pueden representar en un teclado. Los terceros pueden crear EME. Un IME malintencionado puede obtener credenciales u otra información confidencial de esta captura de entrada. Algunas MIE, denominadas IME heredadas, solo funcionarán en aplicaciones de escritorio Windows aplicaciones de escritorio y no en aplicaciones para UWP. Esta mitigación también impedirá que este IME heredado se cargue en la aplicación Windows escritorio especificada.
- **Windows de eventos:** una aplicación puede llamar a la [API SetWinEventHook](/windows/win32/api/winuser/nf-winuser-setwineventhook) para registrar el interés en un evento que tiene lugar. Se especifica una DLL y se puede insertar en el proceso. Esta mitigación fuerza que el enlace se publique en el proceso de registro en lugar de ejecutarse en proceso a través de un DLL inyectado.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

La mayoría de estos puntos de extensión se usan con relativa frecuencia, por lo que el impacto en la compatibilidad suele ser pequeño, especialmente en un nivel de aplicación individual. La única consideración es si los usuarios usan IME heredadas de terceros que no funcionarán con la aplicación protegida.

### <a name="configuration-options"></a>Opciones de configuración

No hay opciones de configuración para esta mitigación.

> [!Note]
> **Deshabilitar puntos de extensión** no tiene modo de auditoría.

## <a name="disable-win32k-system-calls"></a>Deshabilitar llamadas del sistema Win32k

### <a name="description"></a>Descripción

Win32k.sys proporciona una amplia superficie de ataque para un atacante. Como componente de modo kernel, con frecuencia se usa como vector de escape para aplicaciones que están en espacio aislado. Esta mitigación evita las llamadas a win32k.sys bloqueando que un subproceso se convierta en un subproceso gui, al que se le da acceso para invocar funciones de Win32k. Un subproceso no es GUI cuando se crea, pero se convierte en la primera llamada a win32k.sys, o a través de una llamada API a [IsGuiThread](/windows/win32/api/winuser/nf-winuser-isguithread).

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación está diseñada para procesos que no son procesos dedicados a la interfaz de usuario. Por ejemplo, muchos exploradores modernos usarán el aislamiento de procesos e incorporarán procesos que no son de interfaz de usuario. Esta mitigación afectará a cualquier aplicación que muestre una GUI con un solo proceso.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="do-not-allow-child-processes"></a>No permitir procesos secundarios

### <a name="description"></a>Descripción

Esta mitigación impide que una aplicación cree nuevas aplicaciones secundarias. Una técnica común que usan los adversarios es iniciar un proceso de confianza en el dispositivo con entrada malintencionada (un ataque de "vivir fuera de la tierra"), que a menudo requiere iniciar otra aplicación en el dispositivo. Si no hay razones legítimas por las que una aplicación iniciaría un proceso secundario, esta mitigación mitiga ese vector de ataque potencial. La mitigación se aplica estableciendo una propiedad en el token de proceso, que bloquea la creación de un token para el proceso secundario con el mensaje de error STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Si la aplicación inicia aplicaciones secundarias por cualquier motivo, como admitir hipervínculos que inician un explorador o un explorador externo, o que inician otras utilidades en el equipo, esta funcionalidad se romperá con esta mitigación aplicada.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="export-address-filtering"></a>Exportar filtrado de direcciones

### <a name="description"></a>Descripción

El filtrado de direcciones de exportación (EAF) mitiga el riesgo de código malintencionado en la tabla de direcciones de exportación de todos los módulos cargados para buscar módulos que contengan API útiles para su ataque. Esta es una táctica común usada por shellcode. Para mitigar el riesgo de un ataque de este tipo, esta mitigación protege tres módulos de ataque común:

- ntdll.dll
- kernelbase.dll
- kernel32.dll

La mitigación protege la página de memoria del [directorio de exportación que apunta a la [tabla de direcciones de exportación](/windows/win32/debug/pe-format#export-address-table). Esta página de memoria tendrá la [protección PAGE_GUARD](/windows/win32/memory/creating-guard-pages) aplicación a ella. Cuando alguien intenta obtener acceso a esta memoria, generará un STATUS_GUARD_PAGE_VIOLATION. La mitigación controla esta excepción y, si la instrucción de acceso no pasa la validación, se finalizará el proceso.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación es principalmente un problema para aplicaciones como depuradores, aplicaciones de espacio aislado, aplicaciones que usan DRM o aplicaciones que implementan tecnología contra la depuración.

### <a name="configuration-options"></a>Opciones de configuración

**Validar el acceso a módulos** que se abusan habitualmente de vulnerabilidades de seguridad: esta opción, también conocida como EAF+, agrega protecciones para otros módulos con ataques comunes:

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

Además, al habilitar EAF+, esta mitigación agrega la protección PAGE_GUARD a la página que contiene el encabezado "MZ", los dos primeros bytes del encabezado DOS en un archivo [PE](/windows/win32/debug/pe-format#ms-dos-stub-image-only), que es otro aspecto del contenido de memoria conocido que el shellcode puede buscar para identificar módulos potencialmente de interés en la memoria.

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="force-randomization-for-images-mandatory-aslr"></a>Forzar la aleatorización de imágenes (ASLR obligatoria)

### <a name="description"></a>Descripción

La aleatorización de diseño de espacio de direcciones (ASLR) mitiga el riesgo de que un atacante use su conocimiento del diseño de memoria del sistema para ejecutar código que ya está presente en la memoria del proceso y que ya está marcado como ejecutable. Esto puede mitigar el riesgo de que un atacante use técnicas como los ataques de retorno a libc, donde el adversario establece el contexto y, a continuación, modifica la dirección de devolución para ejecutar código existente con contexto que se adapte a la finalidad del adversario.

Aslr obligatorio fuerza una nueva base de todas las DLL dentro del proceso. Un desarrollador puede habilitar ASLR mediante la opción de vinculador [/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019&preserve-view=true) y esta mitigación tiene el mismo efecto.

Cuando el administrador de memoria asigna en la imagen al proceso, ASLR obligatorio volverá a base de archivos DLL y EXE que no han optado por ASLR. Sin embargo, tenga en cuenta que este rebasado no tiene entropía y, por lo tanto, puede colocarse en una ubicación predecible en la memoria. Para la ubicación aleatorizada y rebaseda de archivos binarios, esta mitigación debe emparejarse con Asignaciones de memoria [aleatorias (ASLR de](#randomize-memory-allocations-bottom-up-aslr)abajo hacia arriba).

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Este impacto de compatibilidad de ASLR suele limitarse a aplicaciones anteriores que se crearon con compiladores que hacían suposiciones sobre la dirección base de un archivo binario o que han quitado información de reubicación de base. Esto puede provocar errores impredecibles a medida que el flujo de ejecución intenta saltar a la ubicación esperada, en lugar de a la ubicación real en la memoria.

### <a name="configuration-options"></a>Opciones de configuración

**No permitir imágenes desmontadas:** esta opción bloquea la carga de imágenes a las que se ha quitado información de reubicación. El formato de archivo pe de Windows contiene direcciones absolutas y el compilador también genera una [tabla de reubicación base que el cargador puede usar para buscar todas las referencias de memoria relativas y su desplazamiento, por lo que se pueden actualizar si el binario no se carga en su dirección base preferida. Algunas aplicaciones anteriores quitan esta información en las compilaciones de producción y, por lo tanto, no se pueden volver a basar estos archivos binarios. Esta mitigación bloquea la carga de dichos archivos binarios (en lugar de permitir que se carguen en su dirección base preferida).

> [!Note]
> **Forzar la aleatorización de imágenes (ASLR obligatoria)** no tiene modo de auditoría.

## <a name="import-address-filtering-iaf"></a>Importar filtrado de direcciones (IAF)

### <a name="description"></a>Descripción

La mitigación del filtrado de direcciones de importación (IAF) ayuda a mitigar el riesgo de que un adversario cambie el flujo de control de una aplicación modificando la tabla de direcciones de importación (IAT) para redirigir al código arbitrario que elija el atacante cuando se llama a esa función. Un atacante podría usar este enfoque para secuestrar el control o para interceptar, inspeccionar y bloquear potencialmente llamadas a API confidenciales.

Las páginas de memoria de todas las API protegidas tendrán la [protección PAGE_GUARD](/windows/win32/memory/creating-guard-pages) aplicación a ellas. Cuando alguien intenta obtener acceso a esta memoria, generará un STATUS_GUARD_PAGE_VIOLATION. La mitigación controla esta excepción y, si la instrucción de acceso no pasa la validación, se finalizará el proceso.

Esta mitigación protege las siguientes WINDOWS API:

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación puede detectar aplicaciones legítimas que realizan la interceptación de API y provocar que algunas aplicaciones se bloquean. Algunos ejemplos son el software de seguridad y las correcciones de compatibilidad de aplicaciones.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Aleatorizar asignaciones de memoria (ASLR de abajo hacia arriba)

### <a name="description"></a>Descripción

Aleatorizar asignaciones de memoria (ASLR de abajo hacia arriba) agrega entropía a las reubicaciones, por lo que su ubicación es aleatoria y, por lo tanto, menos predecible. Esta mitigación requiere que la ASLR obligatoria entre en vigor.

El tamaño del espacio de direcciones de 32 bits coloca restricciones prácticas en la entropía que se puede agregar y, por lo tanto, las aplicaciones de 64 bits dificultan que un atacante adivine una ubicación en la memoria.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

La mayoría de las aplicaciones que son compatibles con ASLR obligatorio (rebasado) también son compatibles con la otra entropía de ASLR de abajo hacia arriba. Algunas aplicaciones pueden tener problemas de truncamiento de punteros si están guardando punteros locales en variables de 32 bits (esperando una dirección base inferior a 4 GB) y, por lo tanto, serán incompatibles con la opción de entropía alta (que se puede deshabilitar).

### <a name="configuration-options"></a>Opciones de configuración

No use una **entropía** alta: esta opción deshabilita el uso de ASLR de alta entropía, que agrega 24 bits de entropía (1 TB de varianza) en la asignación de abajo hacia arriba para aplicaciones de 64 bits.

> [!Note]
> **Las asignaciones de memoria aleatorias (ASLR de** abajo hacia arriba) no tienen modo de auditoría.

## <a name="simulate-execution-simexec"></a>Simulación de ejecución (SimExec)

### <a name="description"></a>Descripción

Simular ejecución (SimExec) es una mitigación solo para aplicaciones de 32 bits. Esto ayuda a validar que las llamadas a API confidenciales volverán a las funciones legítimas del autor de la llamada. Para ello, intercepta llamadas en API confidenciales y, a continuación, simula la ejecución de dichas API recorriendo las instrucciones del lenguaje del ensamblado codificado en busca de la instrucción RET, que debe volver al autor de la llamada. A continuación, inspecciona esa función y retrocede en la memoria para buscar la instrucción CALL anterior para determinar si la función y la instrucción CALL coinciden y que el RET no se ha interceptado.

Las API interceptadas por esta mitigación son:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Si se detecta un gadget rop, el proceso finaliza.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Las aplicaciones que realizan la interceptación de la API, en particular el software de seguridad, pueden causar problemas de compatibilidad con esta mitigación.

Esta mitigación es incompatible con la mitigación arbitraria de Protección de código.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-api-invocation-callercheck"></a>Validar invocación de API (CallerCheck)

### <a name="description"></a>Descripción

Validar la invocación de API (CallerCheck) es una mitigación para técnicas de programación orientada a retorno (ROP) que validan que se llamó a api confidenciales desde un llamador válido. Esta mitigación inspecciona la dirección de devolución pasada y, a continuación, desmonta heurísticamente hacia atrás para buscar una llamada encima de la dirección de devolución para determinar si el destino de llamada coincide con el parámetro pasado a la función.

Las API interceptadas por esta mitigación son:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Si se detecta un gadget rop, el proceso finaliza.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Las aplicaciones que realizan la interceptación de la API, en particular el software de seguridad, pueden causar problemas de compatibilidad con esta mitigación.

Esta mitigación es incompatible con la mitigación arbitraria de Protección de código.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-exception-chains-sehop"></a>Validar cadenas de excepciones (SEHOP)

### <a name="description"></a>Descripción

Validar cadenas de excepciones (SEHOP) es una mitigación contra la técnica de sobrescritura del controlador de *excepciones estructurado (SEH).* [El control de excepciones](/windows/win32/debug/structured-exception-handling) estructurado es el proceso mediante el cual una aplicación puede solicitar controlar una excepción determinada. Los controladores de excepciones se encadenan entre sí, de modo que si un controlador de excepciones decide no controlar una excepción determinada, se puede pasar al siguiente controlador de excepciones de la cadena hasta que uno decida controlarla. Dado que la lista de controladores es dinámica, se almacena en la pila. Un atacante puede usar una vulnerabilidad de desbordamiento de pila para sobrescribir el controlador de excepciones con un puntero al código que elija el atacante.

Esta mitigación se basa en el diseño de SEH, donde cada entrada SEH contiene un puntero al controlador de excepciones, así como un puntero al siguiente controlador de la cadena de excepciones. El distribuidor de excepciones llama a esta mitigación, que valida la cadena SEH cuando se invoca una excepción. Comprueba que:

- Todos los registros de cadena de excepciones están dentro de los límites de la pila
- Todos los registros de excepciones están alineados
- No hay punteros de controlador de excepciones que apunten a la pila
- No hay punteros hacia atrás
- La cadena de excepciones termina en un controlador de excepciones final conocido

Si se produce un error en estas validaciones, se anula el control de excepciones y no se controlará la excepción.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Los problemas de compatibilidad con SEHOP son relativamente raros. Es infrecuente que una aplicación se base en dañar la cadena de excepciones. Sin embargo, algunas aplicaciones se verán afectadas por los sutiles cambios en el tiempo, que pueden manifestarse como una condición de carrera que revela un error de varios subprocesos latente en la aplicación.

### <a name="configuration-options"></a>Opciones de configuración

> [!Note]
> **Validar cadenas de excepciones (SEHOP)** no tiene modo de auditoría.

## <a name="validate-handle-usage"></a>Validar el uso de identificadores

### <a name="description"></a>Descripción

*Validar el uso de identificador* es una mitigación que ayuda a proteger contra un atacante mediante un identificador existente para obtener acceso a un objeto protegido. Un [identificador](/windows/win32/sysinfo/handles-and-objects) es una referencia a un objeto protegido. Si el código de aplicación hace referencia a un identificador no válido, esto podría indicar que un adversario está intentando usar un controlador que ha registrado anteriormente (pero que el recuento de referencias de aplicación no tendría en cuenta). Si la aplicación intenta usar un objeto no válido, en lugar de devolver simplemente null, la aplicación producirá una excepción (STATUS_INVALID_HANDLE).

Esta mitigación se aplica automáticamente a Windows store.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Las aplicaciones que no estaban haciendo un seguimiento preciso de las referencias de identificador y que no ajustaban estas operaciones en controladores de excepciones, se verán afectadas potencialmente por esta mitigación.

### <a name="configuration-options"></a>Opciones de configuración

> [!Note]
> **Validar el uso del controlador** no tiene modo de auditoría.

## <a name="validate-heap-integrity"></a>Validar la integridad del montón

### <a name="description"></a>Descripción

La *mitigación* de integridad de montón de validación aumenta el nivel de protección de las mitigaciones de montón en Windows, haciendo que la aplicación finalice si se detecta un daño en el montón. Las mitigaciones incluyen:

- Impedir que se liberara un controlador HEAP
- Realizar otra validación en encabezados de bloque extendidos para asignaciones de montón
- Comprobar que las asignaciones de montón no están ya marcadas como en uso
- Agregar páginas de protección a asignaciones grandes, segmentos de montón y subsegmentos por encima de un tamaño mínimo

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación ya se aplica de forma predeterminada para aplicaciones de 64 bits y para aplicaciones de 32 bits destinadas Windows Vista o posterior. Las aplicaciones heredadas de Windows XP o versiones anteriores son más arriesgadas, aunque los problemas de compatibilidad son poco frecuentes.

### <a name="configuration-options"></a>Opciones de configuración

> [!Note]
> **Validar que la integridad del montón** no tiene modo de auditoría.

## <a name="validate-image-dependency-integrity"></a>Validar la integridad de dependencia de imagen

### <a name="description"></a>Descripción

La *mitigación de dependencias* de imagen validada ayuda a proteger contra ataques que intentan sustituir código por dll que están vinculados estáticamente por archivos binarios Windows archivos binarios. La técnica de plantación de DLL abusa del mecanismo de búsqueda del cargador para insertar código malintencionado, que se puede usar para que el código malintencionado se ejecute en un contexto elevado. Cuando el cargador carga un binario firmado por Windows y, a continuación, carga los archivos DLL de los que depende el binario, estos archivos binarios se comprobarán para asegurarse de que también están firmados digitalmente como un binario Windows. Si no se cumple la comprobación de firma, la dll no se cargará y se producirá una excepción, devolviendo un estado de STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Los problemas de compatibilidad son poco frecuentes. Las aplicaciones que dependen de reemplazar Windows archivos binarios por versiones privadas locales se verán afectadas y también existe un pequeño riesgo de revelar errores de sincronización sutiles en aplicaciones multiproceso.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-stack-integrity-stackpivot"></a>Validar la integridad de la pila (StackPivot)

### <a name="description"></a>Descripción

La mitigación validar la integridad de la pila *(StackPivot)* ayuda a proteger contra el ataque de pivote de pila, un ataque ROP donde un atacante crea una pila falsa en la memoria de montón y, a continuación, hace que la aplicación vuelva a la pila falsa que controla el flujo de ejecución.

Esta mitigación intercepta muchas Windows API e inspecciona el valor del puntero de la pila. Si la dirección del puntero de pila no se encuentra entre la parte inferior y la parte superior de la pila, se registra un evento y, si no está en modo auditoría, se finalizará el proceso.

Las API interceptadas por esta mitigación son:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Las aplicaciones que usan pilas falsas se verán afectadas y también existe un pequeño riesgo de revelar errores de sincronización sutiles en aplicaciones multiproceso.
Las aplicaciones que realizan la interceptación de la API, en particular el software de seguridad, pueden causar problemas de compatibilidad con esta mitigación.

Esta mitigación es incompatible con la mitigación arbitraria de Protección de código.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría:** puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. A continuación, los eventos de auditoría se pueden ver en el visor de eventos o mediante búsqueda avanzada en [Microsoft Defender para endpoint](/microsoft-365/security/defender/advanced-hunting-overview).
