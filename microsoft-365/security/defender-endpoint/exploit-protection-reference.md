---
title: Referencia de protección contra vulnerabilidades de seguridad
keywords: mitigaciones, vulnerabilidades, vulnerabilidad, mitigación, vulnerabilidad de seguridad, vulnerabilidades, emet, mitigations, vulnerabilities, vulnerability, mitigation, exploit, exploits, emet
description: Más información sobre cómo funciona la característica de protección contra vulnerabilidades en Windows
ms.pagetype: security
ms.service: microsoft-365-security
ms.mktglfcycl: manage
ms.sitesec: library
ms.localizationpriority: medium
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.subservice: mde
ms.topic: article
ms.collection: m365-security-compliance
ms.date: 10/19/2021
ms.openlocfilehash: df6b5504abc6dae713e205dca92b6c34a659aa88
ms.sourcegitcommit: 228fa13973bf7c2d91504703fab757f552ae40dd
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/01/2022
ms.locfileid: "67523762"
---
# <a name="exploit-protection-reference"></a>Referencia de protección contra vulnerabilidades de seguridad

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**Se aplica a:**
- [Microsoft Defender para punto de conexión Plan 2](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

> ¿Quiere experimentar Microsoft Defender para punto de conexión? [Regístrese para obtener una prueba gratuita.](https://signup.microsoft.com/create-account/signup?products=7f379fee-c4f9-4278-b0a1-e4c8c2fcdf7e&ru=https://aka.ms/MDEp2OpenTrial?ocid=docs-wdatp-enablesiem-abovefoldlink)

La protección contra vulnerabilidades proporciona protecciones avanzadas para las aplicaciones que el profesional de TI puede aplicar después de que el desarrollador haya creado y distribuido el software.

Este artículo le ayuda a entender cómo funciona la protección contra vulnerabilidades, tanto a nivel de directivas como a nivel de mitigación individual, para ayudarle a crear y aplicar con éxito las directivas de protección contra vulnerabilidades.

## <a name="how-mitigations-are-applied"></a>Cómo se aplican las mitigaciones

Mitigaciones de protección contra vulnerabilidades se aplican por aplicación.

Las mitigaciones se configuran mediante una entrada del Registro para cada programa para el que se configuran las protecciones. Esta configuración se almacena en la entrada del Registro **MitigationOptions** para cada programa (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). Surten efecto cuando se reinicia el programa y siguen vigentes hasta que se cambian y se reinicia el programa de nuevo.

> [!IMPORTANT]
> Opciones de ejecución de archivo de imagen solo permite especificar un nombre de archivo o una ruta de acceso, y no un número de versión, arquitectura o cualquier otro diferenciador. Tenga cuidado de dirigir las mitigaciones a las aplicaciones que tienen nombres o rutas de acceso únicas, y aplíquelas solo en los dispositivos en los que haya probado esa versión y esa arquitectura de la aplicación.

Si configura mitigaciones de protección contra vulnerabilidades mediante un archivo de configuración XML, ya sea a través de PowerShell, directiva de grupo o MDM, al procesar este archivo de configuración XML, se configurará por usted la configuración del Registro individual.

Cuando la directiva que distribuye el archivo XML ya no se aplica, la configuración implementada por este archivo de configuración XML no se quitará automáticamente. Para quitar la configuración de protección contra vulnerabilidades, exporte la configuración XML desde un dispositivo Windows 10 o Windows 11 limpio e implemente este nuevo archivo XML. Como alternativa, Microsoft proporciona un archivo XML como parte de las líneas base de seguridad de Windows para restablecer la configuración de protección contra vulnerabilidades.

Para restablecer la configuración de protección contra vulnerabilidades mediante PowerShell, puede usar el siguiente comando:

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
A continuación se muestra el archivo EP-reset.xml distribuido con las líneas base de seguridad de Windows:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Referencia de mitigación

En las secciones siguientes se detallan las protecciones proporcionadas por cada mitigación de protección contra vulnerabilidades, las consideraciones de compatibilidad para la mitigación y las opciones de configuración disponibles.

## <a name="arbitrary-code-guard"></a>Protección de código arbitrario

### <a name="description"></a>Descripción

La protección de código arbitraria ayuda a protegerse contra un atacante malintencionado que cargue el código de su elección en la memoria a través de una vulnerabilidad de seguridad de la memoria y sea capaz de ejecutar ese código.

La protección de código arbitraria protege una aplicación de la ejecución de código generado dinámicamente (código que no se carga, por ejemplo, desde el propio archivo exe o un archivo DLL). La protección de código arbitraria funciona evitando que la memoria se marque como ejecutable. Cuando una aplicación intenta [asignar memoria](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), comprobamos las marcas de protección. (La memoria se puede asignar con marcas de protección de lectura, escritura y/o ejecución). Si la asignación intenta incluir la marca de protección de [*ejecución*](/windows/win32/memory/memory-protection-constants), se produce un error en la asignación de memoria y devuelve un código de error (STATUS_DYNAMIC_CODE_BLOCKED). Del mismo modo, si una aplicación intenta [cambiar las marcas de protección de la memoria](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) que ya se ha asignado e incluye la marca de protección de [*ejecución*](/windows/win32/memory/memory-protection-constants), el cambio de permisos produce un error y devuelve un código de error (STATUS_DYNAMIC_CODE_BLOCKED).

Al impedir que se establezca la marca de *ejecución*, la característica de prevención de ejecución de datos de Windows 10 y Windows 11 puede proteger contra el puntero de instrucción que se establece en esa memoria y ejecutar ese código.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

La protección de código arbitraria impide asignar memoria como ejecutable, lo que presenta un problema de compatibilidad con enfoques como los compiladores Just-In-Time (JIT). La mayoría de los exploradores modernos, por ejemplo, compilarán JavaScript en código nativo para optimizar el rendimiento. Para admitir esta mitigación, deberán rediseñarse para mover la compilación JIT fuera del proceso protegido. Otras aplicaciones cuyo diseño genera dinámicamente código a partir de scripts u otros lenguajes intermedios serán incompatibles de la misma forma con esta mitigación.

### <a name="configuration-options"></a>Opciones de configuración

**Permitir la exclusión de subprocesos**: puede configurar la mitigación para permitir que un subproceso individual se excluya en esta protección. El desarrollador debe haber escrito la aplicación con conocimiento de esta mitigación y haber llamado a la API [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) con el parámetro *ThreadInformation* establecido en **ThreadDynamicCodePolicy** para poder ejecutar código dinámico en este subproceso.

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-low-integrity-images"></a>Bloquear imágenes de integridad baja

### <a name="description"></a>Descripción

Bloquear imágenes de integridad baja impide que la aplicación cargue archivos que no son de confianza, normalmente porque se han descargado de Internet desde un explorador de espacio aislado.

Esta mitigación bloqueará las cargas de imágenes si la imagen tiene una entrada de control de acceso (ACE) que concede acceso a procesos de IL bajo y que no tiene una ACE de etiqueta de confianza. Lo implementa el administrador de memoria, que impide que el archivo se asigne a la memoria. Si una aplicación intenta asignar una imagen de integridad baja, desencadenará un error STATUS_ACCESS_DENIED. Para obtener más información sobre cómo funcionan los niveles de integridad, consulte [Control de integridad de credenciales](/windows/win32/secauthz/mandatory-integrity-control).

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Bloquear imágenes de integridad baja impedirá que la aplicación cargue archivos que se descargaron de Internet. Si el flujo de trabajo de la aplicación requiere cargar imágenes que se descargan, querrá asegurarse de que se descargan desde un proceso de mayor confianza o se vuelven a etiquetar explícitamente para aplicar esta mitigación.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-remote-images"></a>Bloquear imágenes remotas

### <a name="description"></a>Descripción

Bloquear imágenes remotas ayuda a evitar que la aplicación cargue archivos hospedados en un dispositivo remoto, como un recurso compartido UNC. El bloqueo de imágenes remotas ayuda a proteger contra la carga de archivos binarios en la memoria que se encuentran en un dispositivo externo controlado por el atacante.

Esta mitigación bloqueará las cargas de imágenes si se determina que la imagen está en un dispositivo remoto. Lo implementa el administrador de memoria, que impide que el archivo se asigne a la memoria. Si una aplicación intenta asignar un archivo remoto, desencadenará un error STATUS_ACCESS_DENIED.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Bloquear imágenes remotas impedirá que la aplicación cargue imágenes desde dispositivos remotos. Si la aplicación carga archivos o complementos desde dispositivos remotos, no será compatible con esta mitigación.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-untrusted-fonts"></a>Bloquear fuentes que no son de confianza

### <a name="description"></a>Descripción

Bloquear fuentes que no son de confianza mitiga el riesgo de un error en el análisis de fuentes, lo que hace que el atacante pueda ejecutar código en el dispositivo. GDI solo cargará las fuentes instaladas en el directorio windows\fonts para su procesamiento.

Esta mitigación se implementa en GDI, que valida la ubicación del archivo. Si el archivo no está en el directorio de fuentes del sistema, la fuente no se cargará para el análisis y se producirá un error en la llamada.

Esta mitigación se suma a la mitigación integrada proporcionada en Windows 10 1607 y versiones posteriores, y Windows 11, que mueve el análisis de fuentes fuera del kernel y a un contenedor de aplicaciones en modo de usuario. Cualquier vulnerabilidad de seguridad basada en el análisis de fuentes, como resultado, se produce en un contexto aislado y en una área restringida, lo que reduce significativamente el riesgo. Para obtener más información sobre esta mitigación, consulte el blog [Protección de Windows 10 con mitigaciones de vulnerabilidades de día cero](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/).

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

El uso más común de fuentes fuera del directorio de fuentes del sistema es con [fuentes web](/typography/fonts/font-faq#web). Los exploradores modernos, como Microsoft Edge, usan DirectWrite en lugar de GDI y no se ven afectados. Sin embargo, los exploradores heredados, como Internet Explorer 11 (y el modo IE en el nuevo Microsoft Edge) pueden verse afectados, especialmente con aplicaciones como Office 365, que usan glifos de fuente para mostrar la interfaz de usuario.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="code-integrity-guard"></a>Protección de integridad de código

### <a name="description"></a>Descripción

Protección de integridad de código garantiza que Microsoft firme digitalmente todos los archivos binarios cargados en un proceso. La protección de integridad de código incluye firmas [WHQL](/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs), lo que permitirá que los controladores aprobados por WHQL se ejecuten dentro del proceso.

Esta mitigación se implementa en el administrador de memoria, que impide que el binario se asigne a la memoria. Si intenta cargar un binario que no está firmado por Microsoft, el administrador de memoria devolverá el error STATUS_INVALID_IMAGE_HASH. Al bloquear en el nivel de administrador de memoria, impide que los binarios sean cargados por el proceso y los binarios sean insertados en el proceso.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación bloquea específicamente cualquier binario que no esté firmado por Microsoft. Por lo tanto, será incompatible con la mayoría del software de terceros, a menos que Microsoft Store distribuya (y firme digitalmente) ese software, y se seleccione la opción para permitir la carga de imágenes firmadas por Microsoft Store.

### <a name="configuration-options"></a>Opciones de configuración

**Permitir también la carga de imágenes firmadas por Microsoft Store**: Microsoft Store firmará digitalmente las aplicaciones distribuidas por Microsoft Store y, al agregar esta configuración, la aplicación cargará los binarios que han pasado por el proceso de certificación de almacén.

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="control-flow-guard-cfg"></a>Protección del flujo de control (CFG)

### <a name="description"></a>Descripción

La protección de flujo de control (CFG) mitiga el riesgo de que los atacantes usen vulnerabilidades de daños en la memoria mediante la protección de llamadas de función indirectas. Por ejemplo, un atacante puede usar una vulnerabilidad de desbordamiento de búfer para sobrescribir la memoria que contiene un puntero de función y reemplazar ese puntero de función por un puntero al código ejecutable de su elección (que también se puede haber insertado en el programa).

Esta mitigación se proporciona mediante la inserción de otra comprobación en tiempo de compilación. Antes de cada llamada de función indirecta, se agregan otras instrucciones que comprueban que el destino es un destino de llamada válido antes de que se llame. Si el destino no es un destino de llamada válido, se finaliza la aplicación. Por lo tanto, solo las aplicaciones compiladas con compatibilidad con CFG pueden beneficiarse de esta mitigación.

El kernel de Windows proporciona la comprobación de un destino válido. Cuando se cargan archivos ejecutables, los metadatos de los destinos de llamada indirectos se extraen en tiempo de carga y se marcan como destinos de llamada válidos. Además, cuando se asigna memoria y se marca como ejecutable (por ejemplo, para el código generado), estas ubicaciones de memoria también se marcan como destinos de llamada válidos, para admitir mecanismos como la compilación JIT.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Dado que las aplicaciones deben compilarse para admitir CFG, declaran implícitamente su compatibilidad con él. Por lo tanto, la mayoría de las aplicaciones deben funcionar con esta mitigación habilitada. Dado que estas comprobaciones se compilan en el binario, la configuración que puede aplicar es simplemente deshabilitar las comprobaciones dentro del kernel de Windows. En otras palabras, la mitigación está activada de forma predeterminada, pero puede configurar el kernel de Windows para que siempre devuelva "sí" si más adelante determinas que hay un problema de compatibilidad que el desarrollador de aplicaciones no detectó en sus pruebas, lo que debería ser poco frecuente.

### <a name="configuration-options"></a>Opciones de configuración

**Usar CFG estricto**: en modo estricto, todos los archivos binarios cargados en el proceso deben compilarse para la protección de flujo de control (o no tienen ningún código ejecutable en ellos, como dll de recursos) para poder cargarse.

> [!Note]
> **La protección de flujo de control** no tiene ningún modo de auditoría. Los archivos binarios se compilan con esta mitigación habilitada.

## <a name="data-execution-prevention-dep"></a>Prevención de ejecución de datos (DEP)

### <a name="description"></a>Descripción

La prevención de ejecución de datos (DEP) impide que se ejecute la memoria que no se asignó explícitamente como ejecutable. La DEP ayuda a protegerse contra un atacante que inserta código malintencionado en el proceso, como a través de un desbordamiento del búfer, y luego ejecuta ese código.

Si intenta establecer el puntero de instrucción en una dirección de memoria no marcada como ejecutable, el procesador iniciará una excepción (infracción de protección general), lo que hará que la aplicación se bloquee.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Todos los ejecutables x64, ARM y ARM-64 tienen la DEP habilitada de forma predeterminada y no se puede deshabilitar. Dado que una aplicación nunca se habrá ejecutado sin la DEP, se supone la compatibilidad.

Todos los archivos binarios x86 (32 bits) tienen la DEP habilitada de forma predeterminada, pero la DEP se puede deshabilitar por proceso. Es posible que algunas aplicaciones heredadas antiguas, normalmente aplicaciones desarrolladas antes de Windows XP SP2, no sean compatibles con DEP. Estas aplicaciones suelen generar código dinámicamente (por ejemplo, compilación JIT) o vincular a bibliotecas anteriores (como versiones anteriores de ATL) que generan código dinámicamente.

### <a name="configuration-options"></a>Opciones de configuración

**Habilitar emulación de ATL Thunk**: esta opción de configuración deshabilita la emulación de ATL Thunk. ATL, la biblioteca de plantillas ActiveX, está diseñada para ser lo más pequeña y rápida posible. Para reducir el tamaño binario, usaría una técnica denominada *thunking*. Thunking se suele considerar para interactuar entre aplicaciones de 32 y 16 bits, pero no hay componentes de 16 bits para ATL aquí. En su lugar, para optimizar el tamaño binario, ATL almacenará el código de la máquina en la memoria que no está alineada con palabras (creando un binario más pequeño) y, a continuación, invocará ese código directamente. Los componentes ATL compilados con Visual Studio 7.1 o versiones anteriores (Visual Studio 2003) no asignan esta memoria como ejecutable; la emulación del código thunk resuelve ese problema de compatibilidad. Las aplicaciones que tienen un modelo de extensión binaria (como Internet Explorer 11) a menudo necesitarán tener habilitada la emulación ATL Thunk.

## <a name="disable-extension-points"></a>Deshabilitar los puntos de extensión

### <a name="description"></a>Descripción

Esta mitigación deshabilita varios puntos de extensión para una aplicación, que se pueden usar para establecer la persistencia o elevar privilegios de contenido malintencionado.

Esto incluye lo siguiente:

- **Archivos DLL de AppInit**: cada vez que se inicia un proceso, el sistema cargará el archivo DLL especificado en el contexto del proceso recién iniciado antes de llamar a su función de punto de entrada. [Más información sobre los archivos DLL de AppInit aquí](/windows/win32/winmsg/about-window-classes#application-global-classes). Con esta mitigación aplicada, no se cargan los archivos DLL de AppInit. A partir de Windows 7, los archivos DLL de AppInit deben estar firmados digitalmente, [como se describe aquí](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2). Además, a partir de Windows 8, los archivos DLL de AppInit no se cargarán si SecureBoot está habilitado, [como se describe aquí](/windows/win32/dlls/secure-boot-and-appinit-dlls).
- **IME heredados**: un IME (Editor de métodos de entrada) permite a un usuario escribir texto en un idioma que tiene más caracteres de los que se pueden representar en un teclado. Los terceros pueden crear IME. Un IME malintencionado podría obtener credenciales u otra información confidencial de esta captura de entrada. Algunos IME, denominados IME heredados, solo funcionarán en aplicaciones de escritorio de Windows y no en aplicaciones para UWP. Esta mitigación también impedirá que este IME heredado se cargue en la aplicación de escritorio de Windows especificada.
- **Windows Event Hooks**: una aplicación puede llamar a la [API SetWinEventHook](/windows/win32/api/winuser/nf-winuser-setwineventhook) para registrar su interés en un evento que se está desarrollando. Se especifica un archivo DLL y se puede insertar en el proceso. Esta mitigación obliga a que el enlace se publique en el proceso de registro en lugar de ejecutarse en proceso a través de un archivo DLL insertado.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

La mayoría de estos puntos de extensión se usan con relativamente poca frecuencia, por lo que el impacto en la compatibilidad suele ser pequeño, especialmente en un nivel de aplicación individual. La única consideración es si los usuarios usan IME heredados de terceros que no funcionarán con la aplicación protegida.

### <a name="configuration-options"></a>Opciones de configuración

No hay opciones de configuración para esta mitigación.

> [!Note]
> **Deshabilitar puntos de extensión** no tiene modo de auditoría.

## <a name="disable-win32k-system-calls"></a>Deshabilitar llamadas del sistema de Win32k

### <a name="description"></a>Descripción

Win32k.sys proporciona una amplia superficie de ataque para un atacante. Como componente de modo kernel, se suele destinar como vector de escape para las aplicaciones que están en un espacio aislado. Esta mitigación impide que las llamadas a win32k.sys bloqueen un subproceso para que no se convierta a sí mismo en un subproceso de GUI, al que se concede acceso para invocar funciones Win32k. Un subproceso no es GUI cuando se crea, pero se convierte en la primera llamada a win32k.sys o a través de una llamada API a [IsGuiThread](/windows/win32/api/winuser/nf-winuser-isguithread).

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación está diseñada para procesos dedicados que no son de interfaz de usuario. Por ejemplo, muchos exploradores modernos usarán el aislamiento de procesos e incorporarán procesos que no son de interfaz de usuario. Esta mitigación afectará a cualquier aplicación que muestre una GUI mediante un único proceso.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="do-not-allow-child-processes"></a>No permitir procesos secundarios

### <a name="description"></a>Descripción

Esta mitigación impide que una aplicación cree nuevas aplicaciones secundarias. Una técnica común que usan los adversarios es iniciar un proceso de confianza en el dispositivo con entradas malintencionadas (un ataque "de viva fuera de la tierra"), que a menudo requiere iniciar otra aplicación en el dispositivo. Si no hay razones legítimas para que una aplicación inicie un proceso secundario, esta mitigación mitiga ese potencial vector de ataque. La mitigación se aplica estableciendo una propiedad en el token de proceso, que bloquea la creación de un token para el proceso secundario con el mensaje de error STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Si la aplicación inicia aplicaciones secundarias por cualquier motivo, como la compatibilidad con hipervínculos que inician un explorador o un explorador externo, o que inician otras utilidades en el equipo, esta funcionalidad se interrumpirá con esta mitigación aplicada.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="export-address-filtering"></a>Exportar filtrado de direcciones

### <a name="description"></a>Descripción

El filtrado de direcciones de exportación (EAF) mitiga el riesgo de que el código malintencionado examine la tabla de direcciones de exportación de todos los módulos cargados para buscar módulos que contengan API útiles para su ataque. Se trata de una táctica común usada por shellcode. Para mitigar el riesgo de un ataque de este tipo, esta mitigación protege tres módulos que suelen atacarse:

- ntdll.dll
- kernelbase.dll
- kernel32.dll

La mitigación protege la página de memoria en el [directorio de exportación que apunta a [exportar tabla de direcciones](/windows/win32/debug/pe-format#export-address-table). Esta página de memoria tendrá la protección [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) aplicada. Cuando alguien intenta acceder a esta memoria, se generará una STATUS_GUARD_PAGE_VIOLATION. La mitigación controla esta excepción y, si la instrucción de acceso no pasa la validación, el proceso finalizará.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación es principalmente un problema para aplicaciones como depuradores, aplicaciones de espacio aislado, aplicaciones que usan DRM o aplicaciones que implementan tecnología antidepuración.

### <a name="configuration-options"></a>Opciones de configuración

**Valide el acceso para los módulos que suelen ser objeto de abuso por vulnerabilidades**: esta opción, también conocida como EAF+, agrega protecciones para otros módulos que suelen atacarse:

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

Además, al habilitar EAF+, esta mitigación agrega la protección PAGE_GUARD a la página que contiene el encabezado "MZ", los dos primeros bytes del [encabezado DOS en un archivo PE](/windows/win32/debug/pe-format#ms-dos-stub-image-only), que es otro aspecto del contenido de memoria conocido que shellcode puede buscar para identificar los módulos potencialmente de interés en la memoria.

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="force-randomization-for-images-mandatory-aslr"></a>Forzar la selección aleatoria de imágenes (ASLR es obligatorio)

### <a name="description"></a>Descripción

La aleatorización de diseño de espacio de direcciones (ASLR) mitiga el riesgo de que un atacante use su conocimiento del diseño de memoria del sistema para ejecutar código que ya está presente en la memoria de proceso y que ya está marcado como ejecutable. Esto puede mitigar el riesgo de que un atacante use técnicas como ataques de retorno a libc, donde el adversario establece el contexto y, a continuación, modifica la dirección de retorno para ejecutar el código existente con el contexto que se adapte al propósito del adversario.

ASLR obligatorio fuerza una nueva base de todos los DLL dentro del proceso. Un desarrollador puede habilitar el ASLR mediante la opción del enlazador [/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization) y esta mitigación tiene el mismo efecto.

Cuando el administrador de memoria asigna la imagen en el proceso, ASLR obligatorio rebase forzosamente las DLL y EXE que no hayan optado por ASLR. Sin embargo, tenga en cuenta que este rebasamiento no tiene entropía y, por lo tanto, se puede colocar en una ubicación de predicción en la memoria. En el caso de la ubicación rebasada y aleatoria de los binarios, esta mitigación debe emparejarse con [Aleatorizar asignaciones de memoria (ASLR de abajo a arriba).](#randomize-memory-allocations-bottom-up-aslr)

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Este impacto en la compatibilidad de ASLR normalmente se limita a las aplicaciones más antiguas que se compilaron mediante compiladores que realizaban suposiciones sobre la dirección base de un archivo binario o han eliminado la información de reubicación base. Esto puede provocar errores imprevisibles a medida que el flujo de ejecución intenta saltar a la ubicación esperada, en lugar de a la real, en la memoria.

### <a name="configuration-options"></a>Opciones de configuración

**No permitir imágenes quitadas**: esta opción bloquea la carga de imágenes a las que se ha quitado información de reubicación. El formato de archivo Windows PE contiene direcciones absolutas y el compilador también genera una [tabla de reubicación base que el cargador puede usar para buscar todas las referencias de memoria relativas y su desplazamiento, por lo que se pueden actualizar si el binario no se carga en su dirección base preferida. Algunas aplicaciones anteriores quitan esta información en compilaciones de producción y, por lo tanto, estos archivos binarios no se pueden volver a basar. Esta mitigación impide que se carguen estos binarios (en lugar de permitirles que los carguen en su dirección base preferida).

> [!Note]
> **Forzar aleatorización para imágenes (ASLR obligatorio)** no tiene modo de auditoría.

## <a name="import-address-filtering-iaf"></a>Importar filtrado de direcciones (IAF)

### <a name="description"></a>Descripción

La mitigación del filtrado de direcciones de importación (IAF) ayuda a mitigar el riesgo de que un adversario cambie el flujo de control de una aplicación modificando la tabla de direcciones de importación (IAT) para redirigir a un código arbitrario de la elección del atacante cuando se llama a esa función. Un atacante podría usar este enfoque para secuestrar el control o interceptar, inspeccionar y bloquear potencialmente las llamadas a API confidenciales.

A las páginas de memoria de todas las API protegidas se les aplicará la protección [PAGE_GUARD](/windows/win32/memory/creating-guard-pages). Cuando alguien intenta acceder a esta memoria, se generará una STATUS_GUARD_PAGE_VIOLATION. La mitigación controla esta excepción y, si la instrucción de acceso no pasa la validación, el proceso finalizará.

Esta mitigación protege las siguientes API de Windows:

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación puede detectar las aplicaciones legítimas que realizan la interceptación de API y hacer que algunas aplicaciones se bloqueen. Algunos ejemplos son el software de seguridad y las correcciones de compatibilidad de aplicaciones.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Aleatorizar las asignaciones de memoria (ASLR de abajo a arriba)

### <a name="description"></a>Descripción

La aleatorización de asignaciones de memoria (ASLR de abajo a arriba) agrega entropía a las reubicaciones, por lo que su ubicación es aleatoria y, por tanto, menos predecible. Esta mitigación requiere ASLR obligatorio para que surta efecto.

El tamaño del espacio de direcciones de 32 bits impone restricciones prácticas en la entropía que se puede agregar y, por lo tanto, las aplicaciones de 64 bits dificultan que un atacante adivine una ubicación en la memoria.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

La mayoría de las aplicaciones compatibles con ASLR obligatorio (reajuste) también son compatibles con la otra entropía de ASLR de abajo a arriba. Algunas aplicaciones pueden tener problemas de truncamiento de puntero si guardan punteros locales en variables de 32 bits (se espera una dirección base inferior a 4 GB) y, por tanto, no serán compatibles con la opción de alta entropía (que se puede deshabilitar).

### <a name="configuration-options"></a>Opciones de configuración

**No usar entropía alta**: esta opción deshabilita el uso de ASLR de alta entropía, que agrega 24 bits de entropía (1 TB de varianza) a la asignación de abajo a arriba para aplicaciones de 64 bits.

> [!Note]
> **La aleatorización de asignaciones de memoria (ASLR de abajo a arriba)** no tiene modo de auditoría.

## <a name="simulate-execution-simexec"></a>Simular la ejecución (SimExec)

### <a name="description"></a>Descripción

Simular la ejecución (SimExec) es una mitigación solo para aplicaciones de 32 bits. Esto ayuda a validar que las llamadas a API confidenciales volverán a las funciones legítimas del autor de la llamada. Para ello, intercepta llamadas en API confidenciales y, a continuación, simula la ejecución de esas API recorriendo las instrucciones codificadas del lenguaje de ensamblado en busca de la instrucción RET, que debe volver al autor de la llamada. A continuación, inspecciona esa función y retrocede en la memoria para buscar la instrucción CALL anterior para determinar si la función y la instrucción CALL coinciden, y que el RET no se ha interceptado.

Las API interceptadas por esta mitigación son:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Si se detecta un gadget ROP, se finaliza el proceso.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Las aplicaciones que realizan la interceptación de API, especialmente el software de seguridad, pueden causar problemas de compatibilidad con esta mitigación.

Esta mitigación no es compatible con la mitigación de protección de código arbitraria.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-api-invocation-callercheck"></a>Validar la invocación de la API (CallerCheck)

### <a name="description"></a>Descripción

Validar invocación de API (CallerCheck) es una mitigación para las técnicas de programación orientada a devoluciones (ROP) que valida que se llamó a las API confidenciales desde un llamador válido. Esta mitigación inspecciona la dirección de devolución pasada y, a continuación, desensambla heurísticamente hacia atrás para buscar una llamada encima de la dirección de devolución para determinar si el destino de llamada coincide con el parámetro pasado a la función.

Las API interceptadas por esta mitigación son:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Si se detecta un gadget ROP, se finaliza el proceso.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Las aplicaciones que realizan la interceptación de API, especialmente el software de seguridad, pueden causar problemas de compatibilidad con esta mitigación.

Esta mitigación no es compatible con la mitigación de protección de código arbitraria.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-exception-chains-sehop"></a>Validar cadenas de excepción (SEHOP)

### <a name="description"></a>Descripción

Validar cadenas de excepción (SEHOP) es una mitigación contra la técnica de explotación de *sobrescritura del controlador estructurado de excepciones (SEH)*. [El control estructurado de excepciones](/windows/win32/debug/structured-exception-handling) es el proceso por el que una aplicación puede pedir que controle una excepción determinada. Los controladores de excepciones se encadenan juntos, por lo que si un controlador de excepciones decide no controlar una excepción determinada, se puede pasar al siguiente controlador de excepciones de la cadena hasta que uno decida controlarla. Dado que la lista de controladores es dinámica, se almacena en la pila. Un atacante puede usar una vulnerabilidad de desbordamiento de pila para sobrescribir el controlador de excepciones con un puntero al código que elija el atacante.

Esta mitigación se basa en el diseño de SEH, donde cada entrada SEH contiene un puntero al controlador de excepciones, así como un puntero al siguiente controlador de la cadena de excepciones. El distribuidor de excepciones llama a esta mitigación, que valida la cadena SEH cuando se invoca una excepción. Comprueba que:

- Todos los registros de cadena de excepciones están dentro de los límites de pila
- Todos los registros de excepción están alineados
- No hay punteros de controlador de excepciones que apunten a la pila
- No hay punteros hacia atrás
- La cadena de excepciones finaliza en un controlador de excepciones final conocido

Si se produce un error en estas validaciones, se anula el control de excepciones y no se controlará la excepción.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Los problemas de compatibilidad con SEHOP son relativamente poco frecuentes. No es habitual que una aplicación tome una dependencia para dañar la cadena de excepciones. Sin embargo, algunas aplicaciones se ven afectadas por los cambios sutiles en el tiempo, que se pueden manifestar como una condición de carrera que revela un error de multiproceso latente en la aplicación.

### <a name="configuration-options"></a>Opciones de configuración

> [!Note]
> **Validar cadenas de excepción (SEHOP)** no tiene modo de auditoría.

## <a name="validate-handle-usage"></a>Validar el uso de identificador

### <a name="description"></a>Descripción

*Validar el uso del identificador* es una mitigación que ayuda a protegerse contra un atacante mediante un identificador existente para acceder a un objeto protegido. Un [identificador](/windows/win32/sysinfo/handles-and-objects) es una referencia a un objeto protegido. Si el código de la aplicación hace referencia a un identificador no válido, esto podría indicar que un adversario está intentando usar un identificador que ha registrado previamente (pero que el recuento de referencias de la aplicación no lo sabría). Si la aplicación intenta usar un objeto no válido, en lugar de simplemente devolver NULL, la aplicación generará una excepción (STATUS_INVALID_HANDLE).

Esta mitigación se aplica automáticamente a las aplicaciones de la Tienda Windows.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Las aplicaciones que no realizaban un seguimiento preciso de las referencias de identificador y que no encapsulaban estas operaciones en controladores de excepciones podrían verse afectadas por esta mitigación.

### <a name="configuration-options"></a>Opciones de configuración

> [!Note]
> **Validar el uso del identificador** no tiene modo de auditoría.

## <a name="validate-heap-integrity"></a>Validar la integridad del montón

### <a name="description"></a>Descripción

La mitigación de *validación de la integridad del montón* aumenta el nivel de protección de las mitigaciones de montón en Windows, ya que hace que la aplicación finalice si se detectan daños en el montón. Las mitigaciones incluyen:

- Impedir que se libere un identificador HEAP
- Ejecutar otra validación en encabezados de bloque extendidos para asignaciones de montón
- Comprobar que las asignaciones de montón aún no están marcadas como en uso
- Agregar páginas de protección a asignaciones grandes, segmentos de montón y subsegmentos por encima de un tamaño mínimo

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Esta mitigación ya se aplica de forma predeterminada para las aplicaciones de 64 bits y para las aplicaciones de 32 bits destinadas a Windows Vista o posterior. Las aplicaciones heredadas de Windows XP o versiones anteriores están más en riesgo, aunque los problemas de compatibilidad son poco frecuentes.

### <a name="configuration-options"></a>Opciones de configuración

> [!Note]
> **Validar que la integridad del montón** no tiene modo de auditoría.

## <a name="validate-image-dependency-integrity"></a>Validar la integridad de la dependencia de imagen

### <a name="description"></a>Descripción

La mitigación de *dependencias de validación de imágenes* ayuda a protegerse frente a ataques que intentan sustituir el código por archivos DLL vinculados estáticamente por binarios de Windows. La técnica de plantación de DLL usa el mecanismo de búsqueda del cargador para insertar código malintencionado, que se puede usar para que el código malintencionado se ejecute en un contexto elevado. Cuando el cargador carga un binario firmado por Windows y, a continuación, carga los archivos DLL de los que depende el binario, estos binarios se comprobarán para asegurarse de que también están firmados digitalmente como binarios de Windows. Si se produce un error en la comprobación de firma, no se cargará el archivo DLL y se producirá una excepción, que devolverá un estado de STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Los problemas de compatibilidad son poco comunes. Las aplicaciones que dependen de reemplazar binarios de Windows por versiones privadas locales se verán afectadas y también existe un pequeño riesgo de revelar errores sutiles de control de tiempo en aplicaciones multiproceso.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-stack-integrity-stackpivot"></a>Validar la integridad de la pila (StackPivot)

### <a name="description"></a>Descripción

La mitigación de *validación de la integridad de la pila (StackPivot)* ayuda a proteger contra el ataque Stack Pivot, un ataque ROP en el que un atacante crea una pila falsa en la memoria del montón y, a continuación, hace que la aplicación vuelva a la pila falsa que controla el flujo de ejecución.

Esta mitigación intercepta muchas API de Windows e inspecciona el valor del puntero de pila. Si la dirección del puntero de pila no se encuentra entre la parte inferior y la parte superior de la pila, se registra un evento y, si no está en modo de auditoría, se finalizará el proceso.

Las API interceptadas por esta mitigación son:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Consideraciones de compatibilidad

Las aplicaciones que usan pilas falsas se verán afectadas y también existe un pequeño riesgo de revelar errores sutiles de tiempo en aplicaciones multiproceso.
Las aplicaciones que realizan la interceptación de API, especialmente el software de seguridad, pueden causar problemas de compatibilidad con esta mitigación.

Esta mitigación no es compatible con la mitigación de protección de código arbitraria.

### <a name="configuration-options"></a>Opciones de configuración

**Solo auditoría**: puede habilitar esta mitigación en modo auditoría para medir el posible impacto de compatibilidad en una aplicación. Los eventos de auditoría se pueden ver en el visor de eventos o mediante la búsqueda avanzada en [Microsoft Defender para punto de conexión](/microsoft-365/security/defender/advanced-hunting-overview).
